<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Judicial Courts by Date</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@5.4.0/dist/maplibre-gl.css' />
  <script src='https://unpkg.com/maplibre-gl@5.4.0/dist/maplibre-gl.js'></script>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100%; }
    #controls {
      position: absolute;
      top: 10px; left: 10px;
      background: white; padding: 10px;
      font-family: sans-serif; z-index: 1000;
    }
    #dateLabel {
      font-weight: bold;
    }
  </style>
</head>
<body>

<div id="controls">
  <label for="courtType">Court Type:</label>
  <select id="courtType">
    <option value="district">District</option>
    <option value="circuit">Circuit</option>
  </select>
  <br><br>
  <label for="dateSlider">Date: <span id="dateLabel">1900-01-01</span></label><br>
  <input type="range" id="dateSlider" min="0" max="43830" value="0" step="1" />
</div>

<div id="map"></div>

<script>
let map = new maplibregl.Map({
  container: 'map',
  style: 'https://raw.githubusercontent.com/go2garret/maps/main/src/assets/json/openStreetMap.json',
  center: [-98, 39], zoom: 3
});

let polygonsData = null;
let judgeCounts = null;

const minDate = new Date("1900-01-01");
const maxDate = new Date("2020-01-01");

function daysBetween(start, end) {
  return Math.floor((end - start) / (1000 * 60 * 60 * 24));
}

function dateFromSlider(value) {
  const d = new Date(minDate.getTime());
  d.setDate(d.getDate() + parseInt(value));
  return d.toISOString().split("T")[0];
}

async function loadData() {
  const [geo, judges] = await Promise.all([
    fetch("https://mthatcherclark.github.io/judges_map/courts.geojson").then(r => r.json()),
    fetch("https://mthatcherclark.github.io/judges_map/judge_counts.json").then(r => r.json())
  ]);
  polygonsData = geo;
  judgeCounts = judges;
  updatePolygons();
}

function getJudgeCountOnDate(judgeData, dateStr) {
  const dates = Object.keys(judgeData).sort();
  for (let i = dates.length - 1; i >= 0; i--) {
    if (new Date(dates[i]) <= new Date(dateStr)) {
      return judgeData[dates[i]];
    }
  }
  return null;
}

function updatePolygons() {
  const courtType = document.getElementById('courtType').value;
  const sliderValue = document.getElementById('dateSlider').value;
  const dateStr = dateFromSlider(sliderValue);
  document.getElementById('dateLabel').textContent = dateStr;

  const filtered = polygonsData.features
    .filter(f => f.properties.court_type === courtType)
    .filter(f => {
      const d = new Date(dateStr);
      const start = new Date(f.properties.start_date);
      const end = new Date(f.properties.end_date);
      return d >= start && d <= end;
    })
    .map(f => {
      const cid = f.properties.court_id;
      const count = getJudgeCountOnDate(judgeCounts[cid] || {}, dateStr);
      f.properties.judge_count = count || 0;
      return f;
    });

  const source = map.getSource('courts');
  if (source) {
    source.setData({ type: "FeatureCollection", features: filtered });
  } else {
    map.addSource('courts', {
      type: 'geojson',
      data: { type: "FeatureCollection", features: filtered }
    });
    map.addLayer({
      id: 'courts-layer',
      type: 'fill',
      source: 'courts',
      paint: {
        'fill-color': [
          'interpolate',
          ['linear'],
          ['get', 'judge_count'],
          0, '#f0f9e8',
          10, '#bae4bc',
          20, '#7bccc4',
          30, '#2b8cbe'
        ],
        'fill-opacity': 0.7
      }
    });
  }
}

document.getElementById('courtType').addEventListener('change', updatePolygons);
document.getElementById('dateSlider').addEventListener('input', updatePolygons);

map.on('load', loadData);
</script>

</body>
</html>